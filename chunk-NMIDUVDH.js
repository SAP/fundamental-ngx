import{a as E}from"./chunk-KHQ63QXJ.js";import{Ke as f,Me as C,fa as m,la as g,ne as h,qe as p,se as x}from"./chunk-RMD675XB.js";import"./chunk-2LTBYWJU.js";import"./chunk-VVVYTGKZ.js";import{Ca as c,Kb as e,Ma as r,Xc as u,eb as d,fb as n,gb as t,hb as a}from"./chunk-KJ35K6QL.js";import"./chunk-66YHNWRR.js";var y=(()=>{class o{constructor(){this.translationCustomizationExampleFiles=[{language:"html",code:m("i18n-translation-customization-example/i18n-translation-customization-example.component.html"),fileName:"i18n-translation-customization-example"},{language:"typescript",component:"PlatformI18nTranslationCustomizationExampleComponent",code:m("i18n-translation-customization-example/i18n-translation-customization-example.component.ts"),fileName:"i18n-translation-customization-example",name:"Host component"},{language:"typescript",component:"TranslationWrapper1Component",code:m("i18n-translation-customization-example/translation-wrapper-1.component.ts"),fileName:"translation-wrapper-1",name:"Wrapper component 1"},{language:"typescript",component:"TranslationWrapper2Component",code:m("i18n-translation-customization-example/translation-wrapper-2.component.ts"),fileName:"translation-wrapper-2",name:"Wrapper component 2"}]}static{this.\u0275fac=function(i){return new(i||o)}}static{this.\u0275cmp=r({type:o,selectors:[["ng-component"]],decls:27,vars:1,consts:[["id","language-customization","componentName","i18n"],[3,"exampleFiles"]],template:function(i,l){i&1&&(n(0,"fd-docs-section-title",0),e(1,` Customizing language per component
`),t(),n(2,"description")(3,"p"),e(4," In order to provide language customizations on a component-by-component basis, use the "),n(5,"code"),e(6,"fdLanguagePatch"),t(),e(7," directive. You will also need to import the "),n(8,"code"),e(9,"@fundamental-ngx/i18n"),t(),e(10," module. "),t(),n(11,"p"),e(12," It is also possible to easily override the global language for a certain component by providing "),n(13,"code"),e(14,"FD_LANGUAGE"),t(),e(15," token at any child scope. Use the "),n(16,"code"),e(17,"patchLanguage"),t(),e(18," utility function for this. "),t(),n(19,"p")(20,"b"),e(21,"Note:"),t(),e(22," you should understand that providing an injection token in a certain module will affect the scope where this module is imported. Thus it's recommended to provide overrides on the level of components or lazy loaded modules. "),t()(),n(23,"component-example"),a(24,"app-i18n-translation-customization-example"),t(),a(25,"code-example",1)(26,"separator")),i&2&&(c(25),d("exampleFiles",l.translationCustomizationExampleFiles))},dependencies:[x,p,f,h,g,E],encapsulation:2,changeDetection:0})}}return o})();var v=(()=>{class o{static{this.\u0275fac=function(i){return new(i||o)}}static{this.\u0275cmp=r({type:o,selectors:[["fd-patching-translations-header"]],decls:8,vars:0,template:function(i,l){i&1&&(n(0,"header"),e(1,"Patching translations"),t(),n(2,"description"),e(3," There are cases when you might want to change the translations under a certain context only, for those cases "),n(4,"code"),e(5,"@fundamental-ngx/i18n"),t(),e(6,` exports helpful functions and directives.
`),t(),a(7,"router-outlet"))},dependencies:[C,p,u],encapsulation:2})}}return o})();var M="patching-translations",H=[{path:"",component:v,data:{primary:!0},children:[{path:"",component:y}]}];export{M as LIBRARY_NAME,H as ROUTES};
